//! RCC - Reset and Clock Control

//! 本源码通过 操作 PAC（Peripheral Access Crate）来实现如下效果：
//! 启动 ADC1 的 SCAN 模式

//! 使用 PAC 和直接修改内存地址的操作几乎一一等价，说明见对应的 0adress.rs 文件

#![no_std]
#![no_main]

use panic_rtt_target as _;

use rtt_target::{rprintln, rtt_init_print};

#[cortex_m_rt::entry]
fn main() -> ! {
    rtt_init_print!();

    // 使用 stm32f4 crate 来修改寄存器地址
    //
    // 这个 stm32f4 这个 crate 是由 svd2rust crate 生成的。
    // 从 svd2rust 这个名称我们可以看出来，它的作用应该是将 svd 转换/导入到 rust 中。
    // 而实际上 svd2rust 的功能也是如此，它读取 CMSIS-SVD 格式的 .svd 文件（一种将外设寄存器名称和内存地址对应起来的 xml 文件），
    // 接着将它们转换为 rust 的结构体，并存储为 rust 源码文件，这样我们就不用查阅外设寄存器的内存地址，而是直接使用其名称就可以访问寄存器了
    // svd2rust 除了转换 svd 到 rust 结构体，它还额外创建了对内存地址的基本的读写的操作的函数，方便我们使用

    //stm32f4xx_hal::pac 就是 stm32f4 crate 的再导出
    let device_peripheral = stm32f4xx_hal::pac::Peripherals::take().unwrap();

    // 由于要等待外部震荡源的稳定
    // 这里我们可以看看我们要等待多少次循环才能完成这个操作
    let mut wait_count: u32 = 1;

    const RCC_CR__HSEON__BIT: u32 = 16;

    device_peripheral
        .RCC
        .cr
        // 这里展示了使用 w.bits() 的写法，是最为贴近直接修改内存的方式
        .modify(|_, w| unsafe { w.bits(1 << RCC_CR__HSEON__BIT) }); // 实现了 stm32f4::W 这个 trait，可以直接访问寄存器内容

    // 等待外部震荡源稳定
    // 这里访问某个 bit 的值，使用的是串联的函数
    // 应该来说，这个方法是更加“安全”，也更符合 rust 风格的写法
    while device_peripheral.RCC.cr.read().hserdy().is_not_ready() {
        wait_count += 1
    }

    // 将系统时钟切换为 HSE
    device_peripheral.RCC.cfgr.modify(|_, w| w.sw().hse()); // 实现了 stm32f4::Reg（包含 stm32::W）这个 trait

    // 并等待切换完成
    while !device_peripheral.RCC.cfgr.read().sws().is_hse() {}

    device_peripheral
        .RCC
        .apb2enr
        .modify(|_, w| w.adc1en().enabled());

    device_peripheral.ADC1.cr1.modify(|_, w| w.scan().enabled());

    // 验证阶段
    if device_peripheral.RCC.cfgr.read().sws().is_hse() {
        rprintln!("SYSCLK generated by HSE\r\nwait count: {}\r", wait_count);
    } else {
        rprintln!(
            "SYSCLK NOT generated by HSE\r\nwait count: {}\r",
            wait_count
        );
    };

    loop {}
}
